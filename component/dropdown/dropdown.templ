package dropdown

import (
	"fmt"
	"github.com/axzilla/templui/util"
)

type Props struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type TriggerProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type ContentProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Width      string
	MaxHeight  string
	Align      string
	Side       string
}

type GroupProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type LabelProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type ItemProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Disabled   bool
	Href       string
	Target     string
}

type SeparatorProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type ShortcutProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type SubProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type SubTriggerProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type SubContentProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type PortalProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

templ Dropdown(props ...Props) {
	@Script()
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.ID == "" {
		{{ p.ID = util.RandomID() }}
	}
	<div
		id={ p.ID }
		data-dropdown
		class={ util.TwMerge("relative inline-block text-left", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Trigger(props ...TriggerProps) {
	{{ var p TriggerProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		data-dropdown-trigger
		class={ util.TwMerge("inline-block", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Content(props ...ContentProps) {
	{{ var p ContentProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	{{
		var maxHeight string = "300px"
		if p.MaxHeight != "" {
			maxHeight = p.MaxHeight
		}
		maxHeightClass := fmt.Sprintf("max-h-[%s]", maxHeight)
	}}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		data-dropdown-content
		class={ util.TwMerge(
				"absolute z-50 rounded-md bg-popover p-1 shadow-md focus:outline-none overflow-auto hidden",
				"border border-border",
				"min-w-[8rem]",
				"top-full mt-1 left-0",
				maxHeightClass,
				p.Width,
				p.Class,
		) }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Group(props ...GroupProps) {
	{{ var p GroupProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("py-1", p.Class) }
		role="group"
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Label(props ...LabelProps) {
	{{ var p LabelProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("px-2 py-1.5 text-sm font-semibold", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Item(props ...ItemProps) {
	{{ var p ItemProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.ID == "" {
		{{ p.ID = util.RandomID() }}
	}
	if p.Href != "" {
		<a
			id={ p.ID }
			if p.Href != "" {
				href={ templ.SafeURL(p.Href) }
			}
			if p.Target != "" {
				target={ p.Target }
			}
			class={
				util.TwMerge(
					"flex text-left items-center px-2 py-1.5 text-sm rounded-sm",
					util.If(!p.Disabled, "focus:bg-accent focus:text-accent-foreground hover:bg-accent hover:text-accent-foreground cursor-default"),
					util.If(p.Disabled, "opacity-50 pointer-events-none"),
					p.Class,
				),
			}
			role="menuitem"
			data-dropdown-item
			{ p.Attributes... }
		>
			{ children... }
		</a>
	} else {
		<button
			id={ p.ID }
			class={
				util.TwMerge(
					"w-full text-left flex items-center justify-between px-2 py-1.5 text-sm rounded-sm",
					util.If(!p.Disabled, "focus:bg-accent focus:text-accent-foreground hover:bg-accent hover:text-accent-foreground cursor-default"),
					util.If(p.Disabled, "opacity-50 pointer-events-none"),
					p.Class,
				),
			}
			role="menuitem"
			data-dropdown-item
			disabled?={ p.Disabled }
			{ p.Attributes... }
		>
			{ children... }
		</button>
	}
}

templ Separator(props ...SeparatorProps) {
	{{ var p SeparatorProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("h-px my-1 -mx-1 bg-muted", p.Class) }
		role="separator"
		{ p.Attributes... }
	></div>
}

templ Shortcut(props ...ShortcutProps) {
	{{ var p ShortcutProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<span
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("ml-auto text-xs tracking-widest opacity-60", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</span>
}

templ Sub(props ...SubProps) {
	{{ var p SubProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		data-dropdown-submenu
		class={ util.TwMerge("relative", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ SubTrigger(props ...SubTriggerProps) {
	{{ var p SubTriggerProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<button
		if p.ID != "" {
			id={ p.ID }
		}
		type="button"
		data-dropdown-submenu-trigger
		class={
			util.TwMerge(
				"w-full text-left flex items-center justify-between px-2 py-1.5 text-sm rounded-sm",
				"focus:bg-accent focus:text-accent-foreground hover:bg-accent hover:text-accent-foreground cursor-default",
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		<span>
			{ children... }
		</span>
		<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 ml-auto">
			<path d="M6.5 3L11.5 8L6.5 13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
		</svg>
	</button>
}

templ SubContent(props ...SubContentProps) {
	{{ var p SubContentProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		data-dropdown-submenu-content
		class={ util.TwMerge(
			"absolute z-[9999] min-w-[8rem] rounded-md border bg-popover p-1 shadow-lg hidden",
				"top-0 left-full ml-1",
				p.Class,
		) }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

var dropdownHandle = templ.NewOnceHandle()

templ Script() {
	@dropdownHandle.Once() {
		<script nonce={ templ.GetNonce(ctx) }>
			// Statemanagement - safely check if already defined
			if (typeof window.dropdownState === 'undefined') {
				window.dropdownState = new Map();
			}
			if (typeof window.submenuState === 'undefined') {
				window.submenuState = new Map();
			}
			
			(function() { // IIFE
				function positionSubmenu(trigger, content) {
					if (!trigger || !content) return;
					
					content.style.display = 'block';
					const triggerRect = trigger.getBoundingClientRect();
					const vw = window.innerWidth;
					const vh = window.innerHeight;
					
					// Default position (right side)
					let top = triggerRect.top;
					let left = triggerRect.right + 4;
					
					// Check if overflows right edge
					if (left + content.offsetWidth > vw) {
						left = triggerRect.left - content.offsetWidth - 4;
					}
					
					// Check if overflows bottom
					if (top + content.offsetHeight > vh) {
						top = vh - content.offsetHeight - 10;
					}
					
					// Ensure minimum spacing from edges
					top = Math.max(10, top);
					left = Math.max(10, left);
					
					// Position submenu
					content.style.position = 'fixed';
					content.style.top = `${top}px`;
					content.style.left = `${left}px`;
				}
				
				function closeAllDropdowns() {
					for (const [dropdown, state] of window.dropdownState.entries()) {
						if (state.isOpen) {
							state.close();
						}
					}
				}
				
				function initDropdown(dropdown) {
					// Skip if already initialized
					if (window.dropdownState.has(dropdown)) return;
					
					const trigger = dropdown.querySelector('[data-dropdown-trigger]');
					const content = dropdown.querySelector('[data-dropdown-content]');
					if (!trigger || !content) return;
					
					// Create state object with needed references and flags
					const state = { 
						isOpen: false, 
						clickAwayHandler: null,
						escHandler: null
					};
					
					function closeSubmenus() {
						dropdown.querySelectorAll('[data-dropdown-submenu]').forEach(submenu => {
							const subState = window.submenuState.get(submenu);
							if (subState?.isOpen) {
								clearTimeout(subState.closeTimer);
								subState.content.style.display = 'none';
								subState.isOpen = false;
							}
						});
					}
					
					function close() {
						if (!state.isOpen) return;
						
						content.style.display = 'none';
						closeSubmenus();
						
						// Remove event listeners
						if (state.clickAwayHandler) {
							document.removeEventListener('click', state.clickAwayHandler);
						}
						if (state.escHandler) {
							document.removeEventListener('keydown', state.escHandler);
						}
						
						// Reset state
						state.clickAwayHandler = null;
						state.escHandler = null;
						state.isOpen = false;
					}
					
					function handleClickAway(e) {
						if (!dropdown.contains(e.target)) {
							close();
						}
					}
					
					function handleEsc(e) {
						if (e.key === 'Escape') {
							close();
						}
					}
					
					function open() {
						if (state.isOpen) return;
						
						closeAllDropdowns();
						content.style.display = 'block';
						state.isOpen = true;
						
						// Set up and store event handlers
						state.clickAwayHandler = handleClickAway;
						state.escHandler = handleEsc;
						
						// Add event listeners
						setTimeout(() => {
							document.addEventListener('click', state.clickAwayHandler);
						}, 0);
						document.addEventListener('keydown', state.escHandler);
					}
					
					// Toggle dropdown on trigger click
					trigger.addEventListener('click', e => {
						e.stopPropagation();
						if (state.isOpen) {
							close();
						} else {
							open();
						}
					});
					
					// Close dropdown when an item is clicked
					for (const item of dropdown.querySelectorAll('[data-dropdown-item]')) {
						item.addEventListener('click', close);
					}
					
					// Initialize submenus
					for (const submenu of dropdown.querySelectorAll('[data-dropdown-submenu]')) {
						initSubmenu(submenu);
					}
					
					// Store functions in state for access from outside
					state.close = close;
					
					// Store dropdown state
					window.dropdownState.set(dropdown, state);
				}
				
				function initSubmenu(submenu) {
					// Skip if already initialized
					if (window.submenuState.has(submenu)) return;
					
					const trigger = submenu.querySelector('[data-dropdown-submenu-trigger]');
					const content = submenu.querySelector('[data-dropdown-submenu-content]');
					if (!trigger || !content) return;
					
					const state = {
						isOpen: false,
						closeTimer: null,
						trigger,
						content
					};
					
					function openSubmenu() {
						clearTimeout(state.closeTimer);
						if (state.isOpen) return;
						
						state.isOpen = true;
						document.body.appendChild(content);
						content.style.display = 'block';
						positionSubmenu(trigger, content);
					}
					
					function startCloseTimer() {
						clearTimeout(state.closeTimer);
						state.closeTimer = setTimeout(() => {
							if (state.isOpen) {
								content.style.display = 'none';
								state.isOpen = false;
							}
						}, 200);
					}
					
					// Add event listeners
					trigger.addEventListener('mouseenter', openSubmenu);
					trigger.addEventListener('focus', openSubmenu);
					trigger.addEventListener('mouseleave', startCloseTimer);
					trigger.addEventListener('blur', startCloseTimer);
					
					content.addEventListener('mouseenter', () => clearTimeout(state.closeTimer));
					content.addEventListener('mouseleave', startCloseTimer);
					
					// Store state
					window.submenuState.set(submenu, state);
				}
				
				function initAllComponents(root = document) {
					if (root instanceof Element && root.matches('[data-dropdown]')) {
						initDropdown(root);
					}
					if (root && typeof root.querySelectorAll === 'function') {
						for (const dropdown of root.querySelectorAll('[data-dropdown]')) {
							initDropdown(dropdown);
						}
					}
				}

				const handleHtmxSwap = (event) => {
					const target = event.detail.target || event.target;
					if (target instanceof Element) {
						setTimeout(() => initAllComponents(target), 0);
					}
				};
				
				document.addEventListener('DOMContentLoaded', () => initAllComponents());

				document.body.addEventListener('htmx:beforeSwap', (evt) => {
					// Keep existing beforeSwap logic for cleanup
					const target = evt.detail.target || evt.detail.elt; // Handle different HTMX versions/contexts
					if (!target || typeof target.matches !== 'function') return;

					const cleanupDropdown = (dropdown) => {
						const state = window.dropdownState.get(dropdown);
						if (state?.isOpen) state.close(); // Close if open
						window.dropdownState.delete(dropdown);
					};

					const cleanupSubmenu = (submenu) => {
						const state = window.submenuState.get(submenu);
						if (state) {
							clearTimeout(state.closeTimer);
							if (state.isOpen && state.content.parentNode === document.body) {
								try { document.body.removeChild(state.content); } catch(e) {}
							}
							window.submenuState.delete(submenu);
						}
					};

					// Cleanup target itself if it's a dropdown or submenu
					if (target.matches('[data-dropdown]')) cleanupDropdown(target);
					if (target.matches('[data-dropdown-submenu]')) cleanupSubmenu(target);

					// Cleanup descendants
					if (typeof target.querySelectorAll === 'function') {
						target.querySelectorAll('[data-dropdown]').forEach(cleanupDropdown);
						target.querySelectorAll('[data-dropdown-submenu]').forEach(cleanupSubmenu);
					}
				});
				
				document.body.addEventListener('htmx:afterSwap', handleHtmxSwap);
				document.body.addEventListener('htmx:oobAfterSwap', handleHtmxSwap);
			})(); // End of IIFE
		</script>
	}
}
