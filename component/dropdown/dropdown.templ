package dropdown

import (
	"context"
	"fmt"
	"github.com/axzilla/templui/component/popover"
	"github.com/axzilla/templui/util"
)

// Context key for content ID
type contentIDKeyType struct{}

var contentIDKey = contentIDKeyType{}

// Context key for sub-content ID (Re-added)
type subContentIDKeyType struct{}

var subContentIDKey = subContentIDKeyType{}

type Props struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type TriggerProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type ContentProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Width      string
	MaxHeight  string
	Align      string
	Side       string
}

type GroupProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type LabelProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type ItemProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Disabled   bool
	Href       string
	Target     string
}

type SeparatorProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type ShortcutProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type SubProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type SubTriggerProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type SubContentProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type PortalProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

templ Dropdown(props ...Props) {
	@Script()
	{{
		var p Props
		if len(props) > 0 {
			p = props[0]
		}
		// Ensure Content has an ID for popover trigger/content linking
		contentID := p.ID
		if contentID == "" {
			contentID = util.RandomID()
		}

		// Provide contentID via context
		ctx = context.WithValue(ctx, contentIDKey, contentID)

		// Define props for popover component
		popoverProps := popover.Props{
			Class: p.Class,
		}
	}}
	// Use @popover shorthand with props variable
	@popover.Popover(popoverProps) {
		// Children will include Trigger and Content
		{ children... }
	}
}

templ Trigger(props ...TriggerProps) {
	{{
		var p TriggerProps
		if len(props) > 0 {
			p = props[0]
		}
		// Retrieve contentID from context
		contentID, ok := ctx.Value(contentIDKey).(string)
		if !ok {
			// Handle error or default - perhaps log or return an error component
			contentID = "fallback-content-id" // Example fallback
		}

		// Define props for trigger component
		triggerProps := popover.TriggerProps{
			ID:          p.ID,
			For:         contentID,                // Link trigger to content via ID from context
			TriggerType: popover.TriggerTypeClick, // Default dropdown behavior is click
		}
	}}
	// Use @popover shorthand with props variable
	@popover.Trigger(triggerProps) {
		<span
			class={ util.TwMerge("inline-block", p.Class) }
			{ p.Attributes... }
		>
			{ children... }
		</span>
	}
}

templ Content(props ...ContentProps) {
	{{ var p ContentProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	// Retrieve contentID from context
	{{ contentID, ok := ctx.Value(contentIDKey).(string) }}
	if !ok {
		// Handle error or default
		{{ contentID = "fallback-content-id" }} // Must match fallback in Trigger
	}
	{{
		var maxHeight string = "300px"
		if p.MaxHeight != "" {
			maxHeight = p.MaxHeight
		}
		maxHeightClass := fmt.Sprintf("max-h-[%s]", maxHeight)
	}}
	// Use popover.Content
	@popover.Content(popover.ContentProps{
		ID:        contentID,                    // Use ID from context
		Placement: popover.PlacementBottomStart, // Common dropdown placement
		Offset:    4,                            // Small offset
		Class: util.TwMerge(
			"z-50 rounded-md bg-popover p-1 shadow-md focus:outline-none overflow-auto", // Keep dropdown styles
			"border border-border",
			"min-w-[8rem]",
			maxHeightClass,
			p.Width,
			p.Class, // Merge user-provided classes
		),
		Attributes: p.Attributes,
		// DisableClickAway: false, // Default popover behavior is fine
		// DisableESC: false,      // Default popover behavior is fine
		// ShowArrow: false,       // Dropdowns usually don't have arrows
	}) {
		{ children... }
	}
}

templ Group(props ...GroupProps) {
	{{ var p GroupProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("py-1", p.Class) }
		role="group"
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Label(props ...LabelProps) {
	{{ var p LabelProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("px-2 py-1.5 text-sm font-semibold", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Item(props ...ItemProps) {
	{{ var p ItemProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.ID == "" {
		{{ p.ID = util.RandomID() }}
	}
	if p.Href != "" {
		<a
			id={ p.ID }
			if p.Href != "" {
				href={ templ.SafeURL(p.Href) }
			}
			if p.Target != "" {
				target={ p.Target }
			}
			class={
				util.TwMerge(
					"flex text-left items-center px-2 py-1.5 text-sm rounded-sm",
					util.If(!p.Disabled, "focus:bg-accent focus:text-accent-foreground hover:bg-accent hover:text-accent-foreground cursor-default"),
					util.If(p.Disabled, "opacity-50 pointer-events-none"),
					p.Class,
				),
			}
			role="menuitem"
			data-dropdown-item
			{ p.Attributes... }
		>
			{ children... }
		</a>
	} else {
		<button
			id={ p.ID }
			class={
				util.TwMerge(
					"w-full text-left flex items-center justify-between px-2 py-1.5 text-sm rounded-sm",
					util.If(!p.Disabled, "focus:bg-accent focus:text-accent-foreground hover:bg-accent hover:text-accent-foreground cursor-default"),
					util.If(p.Disabled, "opacity-50 pointer-events-none"),
					p.Class,
				),
			}
			role="menuitem"
			data-dropdown-item
			disabled?={ p.Disabled }
			{ p.Attributes... }
		>
			{ children... }
		</button>
	}
}

templ Separator(props ...SeparatorProps) {
	{{ var p SeparatorProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("h-px my-1 -mx-1 bg-muted", p.Class) }
		role="separator"
		{ p.Attributes... }
	></div>
}

templ Shortcut(props ...ShortcutProps) {
	{{ var p ShortcutProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<span
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("ml-auto text-xs tracking-widest opacity-60", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</span>
}

templ Sub(props ...SubProps) {
	{{
		var p SubProps
		if len(props) > 0 {
			p = props[0]
		}
		// Generate ID for the SubContent
		subContentID := p.ID
		if subContentID == "" {
			subContentID = util.RandomID()
		}
		// Provide subContentID via context
		ctx = context.WithValue(ctx, subContentIDKey, subContentID)
	}}
	// Render the original div structure, just providing context
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		data-dropdown-submenu
		class={ util.TwMerge("relative", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
		// Should contain SubTrigger and SubContent
	</div>
}

templ SubTrigger(props ...SubTriggerProps) {
	{{
		var p SubTriggerProps
		if len(props) > 0 {
			p = props[0]
		}
		// Retrieve subContentID from context
		subContentID, ok := ctx.Value(subContentIDKey).(string)
		if !ok {
			subContentID = "fallback-subcontent-id"
		}

		// Define props for the popover trigger
		triggerProps := popover.TriggerProps{
			ID:          p.ID,
			For:         subContentID,
			TriggerType: popover.TriggerTypeHover,
		}
	}}
	// Use popover.Trigger, wrapping the original button appearance
	@popover.Trigger(triggerProps) {
		<button
			type="button"
			data-dropdown-submenu-trigger
			class={
				util.TwMerge(
					"w-full text-left flex items-center justify-between px-2 py-1.5 text-sm rounded-sm",
					"focus:bg-accent focus:text-accent-foreground hover:bg-accent hover:text-accent-foreground cursor-default",
					p.Class,
				),
			}
			{ p.Attributes... }
		>
			<span>
				{ children... }
			</span>
			<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 ml-auto">
				<path d="M6.5 3L11.5 8L6.5 13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
			</svg>
		</button>
	}
}

templ SubContent(props ...SubContentProps) {
	{{
		var p SubContentProps
		if len(props) > 0 {
			p = props[0]
		}
		// Retrieve subContentID from context
		subContentID, ok := ctx.Value(subContentIDKey).(string)
		if !ok {
			subContentID = "fallback-subcontent-id"
		}

		// Define props for the popover content
		contentProps := popover.ContentProps{
			ID:            subContentID,
			Placement:     popover.PlacementRightStart,
			Offset:        -4,  // Adjust as needed
			HoverDelay:    100, // ms
			HoverOutDelay: 200, // ms
			Class: util.TwMerge(
				"z-[9999] min-w-[8rem] rounded-md border bg-popover p-1 shadow-lg", // Original style minus positioning
				p.Class,
			),
			Attributes: p.Attributes,
		}
	}}
	// Use popover.Content
	@popover.Content(contentProps) {
		{ children... }
	}
}

var dropdownHandle = templ.NewOnceHandle()

templ Script() {
	<script nonce={ templ.GetNonce(ctx) }>
		(function() { // IIFE
			// Click handler for *non-submenu-trigger* items
			function handleDropdownItemClick(event) {
				const item = event.currentTarget;
				const popoverContent = item.closest('[data-popover-id]');
				if (popoverContent) {
					const popoverId = popoverContent.dataset.popoverId;
					if (window.closePopover) {
						// Close the specific popover (could be main dropdown or a submenu)
						window.closePopover(popoverId, true);

						// Try to close the main dropdown as well if the click was in a submenu
						// Find the popover associated with the main Dropdown component.
						// We assume the main Dropdown's Content is a direct child of the main Popover.
						// This selector might need adjustment depending on the final DOM structure.
                        // Let's try finding the closest popover trigger that ISN'T a submenu trigger.
                        // This is getting complex, let's simplify: just close the *current* popover.
                        // The user can click outside if they want to close the main one.
						// -- Simplified logic: Only close the current popover --
					} else {
						console.warn("popover.Script's closePopover function not found.");
						document.body.click(); // Fallback
					}
				}
			}

			function initItemListeners(root = document) {
				// Select items with 'data-dropdown-item' but not 'data-dropdown-submenu-trigger'
				const items = root.querySelectorAll('[data-dropdown-item]:not([data-dropdown-submenu-trigger])');
				items.forEach(item => {
					item.removeEventListener('click', handleDropdownItemClick);
					item.addEventListener('click', handleDropdownItemClick);
				});
			}

			document.addEventListener('DOMContentLoaded', () => initItemListeners());

			const handleHtmxSwapForItems = (event) => {
				const target = event.detail.target || event.target;
				if (target instanceof Element) {
					setTimeout(() => initItemListeners(target), 0);
				}
			};

			document.body.addEventListener('htmx:afterSwap', handleHtmxSwapForItems);
			document.body.addEventListener('htmx:oobAfterSwap', handleHtmxSwapForItems);

		})(); // End of IIFE
	</script>
}
